# Тихонов Тимофей Павлович БПИ212 ОС ИДЗ 4 ВАРИАНТ 19. #
## UDP. ##

### Условие задачи: ###

Задача о болтунах. N болтунов имеют телефоны. Они либо ждут
звонков, либо звонят друг другу, чтобы побеседовать. Выбор этого
состояния осуществляется случайно и равновероятно. Если телефон случайного абонента занят, болтун будет звонить другому абоненту, пока ему кто-нибудь не ответит. Побеседовав некоторое время, болтун равновероятно или ждет звонка, или звонит на другой случайный номер. Создать приложение, моделирующее поведение болтунов. Каждый болтун — отдельный клиент. Сервер
получает число болтунов при запуске и является коммутатором.

### Общий комментарий ###

Разработанное приложение позволяет задавать ip-адрес сервера, к которому подключаются клиенты. Запускать сначала сервер - потом клиентов.
Код документирован комментариями на английском и русском. 

При замене реализации с TCP на UDP были следующие изменения:
1) убраны connect() и accept(), т.к. протокол не требует подключения сокетов
2) при создании сокета указываем опции для протокола UDP:
```c
sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
```
3) разрешается широковещательная рассылка (broadcastPermission = 1):
```c
setsockopt(sock, SOL_SOCKET, SO_BROADCAST, (void *)&broadcastPermission, sizeof(broadcastPermission)
```
4) передача и приём данных осуществляются с помощью следущих ф-й:
```c
if (sendto(sock, &request, sizeof(struct request), 0, (struct sockaddr *)&servaddr, sizeof(servaddr)) != sizeof(request)) 
if (recvfrom(sock, &response, sizeof(struct response), 0, NULL, NULL) != sizeof(response))
```

### Компиляция через эти команды(компилируем вместе с библиотекой): ###
```sh
gcc UDPLib.c Client.c -o Client
gcc UDPLib.c Server.c -o Server
```
### Запуск сервера (port) (кол-во болтунов не менять - всегда 5): ###
```sh
./Server 5000 5
```
### Запуск клиентов можно осуществлять вручную. (ip server) (port) (unique boltun id) ###
```sh
./Client 127.0.0.1 5000 1
./Client 127.0.0.1 5000 2
./Client 127.0.0.1 5000 3
./Client 127.0.0.1 5000 4
./Client 127.0.0.1 5000 4
```

### Работа на 4-5 балла : ###
Сервер разделяется на потоки для каждого из клиентов, при этом храня о них информацию в статической памяти. Изначально программа сделана для 5 болтунов. Общение между клиентами и сервером-коммутатором происходит посредство сигналов. Структура данных Call содержит id (чтобы различать запросы от каждого из болтунов хранящиеся на сервере), caller_id (равен -1 если болтун ждет звонка) и receiver_id - задан айди болтуна если он ожидает звонок или айди того, кому совершается звонок от самого болтуна.

Болтун запускаясь, реашет ожидать ему звонка или звонить самому, он возвращается к этому снова и снова после любого удачного звонка или после того как ему не ответил ни один из болтунов. 

Вся логика работает корректно, есть иногда ошибки в самом выводе, думаю это из-за переполнения буфера.
![photo_2023-09-25_21-42-14](https://github.com/timtikh/OS_IDZ_4/assets/95489979/a61a4530-8291-4243-a6d9-dea58838551f)

Логика также как в TCP расписана на enum - понятные статусы на английском для каждого из запросов или ответов.
![photo_2023-09-25_17-57-49](https://github.com/timtikh/OS_IDZ_3/assets/95489979/b048ecf4-5a09-454b-8670-91c591bdd5c0)



